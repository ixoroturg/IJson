## Первый тест, общее положение

Библиотека для работы с JSON в java, разработанная ixoroturg

Подклчючение:
```
import ixoroturg.json.*;
```
`Json` - интерфейс, `IJson` - реализация. Дерево `json` представляет из себя сложную и связанную структуру из `IJsonEntry`. `IJson` является лишь оболочкой над этой структурой,
которая знает, как управлять всей структурой

Чтобы спарсить json есть следующие методы (они статичные):
```
Json IJson.of(String value); // Парсит строку как json
Json IJson.of(InputStream stream); // Прочитает ВЕСЬ поток и спарсит его. НЕ ЗАКРЫВАЕТ!!!
Json IJson.of(Reader reader); // Прочитает ВЕСЬ поток и спарсит его. НЕ ЗАКРЫВАЕТ!!!
```
Чтобы получить строковое представление, используйте:
```
String IJson.toString(); // стандартый метод java.lang.Object, выводит в 1 строку
String IJson.toStringFormat(); // возвращает отформатированную строку
```
Следующие методы делают тоже самое, но не возвращают строку, а пишут в потоки. НЕ ЗАКРЫВАЮТ И НЕ flush() ИХ!!!:
```
void IJson.writeTo(OutputStream stream);
void IJson.writeTo(OutputStream stream);
void IJson.writeToFormat(Writer writer); // форматированный
void IJson.writeToFormat(Writer writer); // форматированный
```

Поведение настраивается через глобальный статический `IJsonSetting`. Лучше всего настроить 1 раз в самом начале программы и не трогать в дальнейшем!
В javadoc должно быть описание, если нет, то смотрите settings.txt, а я это когда-нибудь исправлю

`IJson` позволяет использовать синтаксис `JavaScript`, если включены следующие настройки (лучше посмотрите весь `IJsonSetting`). Все 3 по умолчанию выключены:

- `KEY_DELIMETER` - символ разделителя, как `one.two` в `JavaScript`. Если `0`, то выключено
- `PARENT_CHARACTER` - символ родителя. Если встречено `\p`, где `PARENT_CHARACTER = 'p'`, то это интерпретируется, как ссылка на родителя. Если `0`, то выключено
- `USE_ARRAY_SYNTAX` - при `false` интерпретирует `property[2]` как полное имя свойства, а если `true`, то как `2` элемент массива `property`

Используйте `setBufferSize(int power)`, чтобы управлять размером буфера, который используется при парсинге. Позволяет подкорректировать размер, чтобы оставаться в кеше процессора и
значительно уменьшить кеш-промахи при парсинге.

## Добавление элементов

Учтите, что ключ резолвится в соответствии с настройками синтаксиса `JavaScript`.
Для всех методов существуют все перегруженные версии для:
- `byte`
- `short`
- `int`
- `long`
- `float`
- `double`
- `boolean`
- `String`
- `Json` - только для добавления. Для получения используйте `get(...)`, о котором будет дальше.

Также есть версии для массивов всех типов.
Для добавления используйте:
```
put(key, value); // кладёт value по пути key.
add(value); // кладёт value в текущий массив.
add(key, value); // кладёт value в массив по пути key
add(value[]); // создаёт новый Json массив и кладёт его
add(key, value[]); // создаёт новый Json массив и кладёт его по пути key
addAll(value[]); // не создаёт новый массив, а распаковывает элементы в этот
addAll(key, value[]); // распаковывает массов по пути key
```
`IJson` воспринимает `null` как полноценный `null` и на проверку существования `has(key)` будет выдавать `false`, т.к. иначе вы бы могли получить, что `has(key) = true; get(key).someMethod()`
и получить `NullPointerException`.

## Получение элементов
Для получения типа `Json` используйте методы из секции `Путешествие по json`
Для получения существуют множество методов и все их перегруженные версии:
```
getType(); // получить значение указанного типа
getType(key); // получить значение указанного типа по пути key
getType(int index); // получает значение указанного типа по индексу массива
getTypeOr(key, value); // получить значение указанного типа по пути key. Если конечной точки не существует, то вернёт value. Если не существует промежуточной точки, то выбросит JsonNoSuchPropertyException
getTypeOr(int index, value); // как getTypeOr(int index), но если индекса не существует, то вернёт value 
getTypeArray(); // массив указанного типа
getTypeArray(key); // массив указанного типа по пути key
getTypeArray(int index); // возвращает массив указанного типа по индексу массива index
getTypeArray(key, value); // то же самое, но если нет конечной точки, то вернёт value
getTypeArrayOr(int index, value[]); // возвращает массив указанного типа по индексу массива index. Если такого индекса не существует, то вернёт value[]

getTypeStream(); // возвращает Stream указанного типа.
getTypeStream(key); // возвращает Stream указанного типа по пути key.
getTypeStream(int index); // возвращает Stream указанного типа по индексу index в массиве
getTypeStreamOr(key, value); // возвращает Stream указанного типа по пути key. Если нет конечного значения, то вернёт Arrays.stream(value)
getTypeStreamOr(int index, value); // возвращает Stream указанного типа по индексу index в массиве. Если такого индекса нет, то вернёт Arrays.stream(value)
```

## Путешествие по json

Для путешествия можно использовать следующие методы:
- `get(key)` - получить НОВЫЙ `Json` со ссылкой на старое дерево по пути `key`
- `go(key)` - передвинет текущий `Json` на `key`
- `get(int index)` - получит НОВЫЙ `Json` со ссылкой на старое дерево из массива с индексом `index`
- `go(int index)` - передвинет текущий `Json` на элемент массива с номером `index`
- `back()` - подняться на 1 родителя наверх
- `back(int n)` - подняться на `n` родителей наверх. Если передан `0`, то поднимается на самый верх дерева

## Экзотические `put` и `get`

```
putObject(key); // кладёт пустой объект по пути key
putGetObject(key); // аналог putObject(key).get(key);
putGoObject(key); // аналог putObject(key).go(key);
putArray(); // версии для массова
putGetArray();
putGoArray();

addObject(); // кладёт пустой объект в текущий массив
addGetObject(); // кладёт пустой объект в текущий и возвращает НОВЫЙ Json со ссылкой на этот объект
addGoObject(); // кладёт пустой объект в текущий массив и перемещает на него текущий Json
addArray(); // версии для массива
addGetArray();
addGoArray();

addObject(key); // аналог addObject, но по пути key
addGetObject(key);
addGoObject(key);
addArray(key); // версии для массива
addGetArray(key);
addGoArray(key);
```

## Разное
```
boolean has(key); // проверяет наличие объекта по пути key. Если такого объекта нет, или он равен null, то возвращает false
boolean has(int index); // проверяет наличие объекта по индексу index. Если такого индекса нет, то возвращает false

// ВНИМАНИЕ!!! это char! Для размера byte[] умножьте полученный результат на 2!!!
int buffSize(); // возвращает размер char[] буфера, куда полностью поместится строковое представление Json
int buffSizeFormat(); // возвращает размер char[] буфера, куда полностью поместится отформатированное строковое представление Json

String getPropertyName(); // возвращает строку с именем свойства. Работает, только если родитель это объект
String getPropertyNameOr(String value); // аналогично getPropertyName(), но если родителя нет или он не объект, то возвращает value

long getParseTime(); // возвращает количество миллисекунд, потраченных на парсинг. Работает только при парсинге через IJson.of(). На добавленные в дальнейшем свойства не распространяется
IJsonEntry getInnerRepresentation(); // возвращает объект внутреннего представления дерева. У него нет public свойств, так что его единственное назначение это передача в IJson.ofInnerRepresentation(entry) для создания нового Json со ссылкой на старое дерево

equals(Object obj); // метод переопределён. Возвращает true, если объекты равны. Для массивов также важен порядок. Для объектов порядок не важен.
iClone(); // т.к. стандартный java.lang.Object.clone() имеет модификатор protected, то это его открытая версия. Создаёт НОВЫЙ Json с ПОЛНОСТЬЮ НОВЫМ деревом

Массив также имеет интерфейс Iterable
```


