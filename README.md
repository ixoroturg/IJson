## Первый тест, общее положение

Библиотека для работы с JSON в java, разработанная ixoroturg

Подклчючение:
```
import ixoroturg.json.*;
```
`Json` - интерфейс, `IJson` - реализация.

Чтобы спарсить json есть следующие методы (они статичные):
```
Json IJson.of(String value); // Парсит строку как json
Json IJson.of(InputStream stream); // Прочитает ВЕСЬ поток и спарсит его. НЕ ЗАКРЫВАЕТ!!!
Json IJson.of(Reader reader); // Прочитает ВЕСЬ поток и спарсит его. НЕ ЗАКРЫВАЕТ!!!
```
Чтобы получить строковое представление, используйте:
```
String IJson.toString(); // стандартый метод java.lang.Object, выводит в 1 строку
String IJson.toStringFormat(); // возвращает отформатированную строку
```
Следующие методы делают тоже самое, но не возвращают строку, а пишут в потоки. НЕ ЗАКРЫВАЮТ И НЕ flush() ИХ!!!:
```
void IJson.writeTo(OutputStream stream);
void IJson.writeTo(OutputStream stream);
void IJson.writeToFormat(Writer writer); // форматированный
void IJson.writeToFormat(Writer writer); // форматированный
```

Поведение настраивается через глобальный статический `IJsonSetting`. Лучше всего настроить 1 раз в самом начале программы и не трогать в дальнейшем!
В javadoc должно быть описание, если нет, то смотрите settings.txt, а я это когда-нибудь исправлю

`IJson` позволяет использовать синтаксис `JavaScript`, если включены следующие настройки (лучше посмотрите весь `IJsonSetting`). Все 3 по умолчанию выключены:

- `KEY_DELIMETER` - символ разделителя, как `one.two` в `JavaScript`. Если `0`, то выключено
- `PARENT_CHARACTER` - символ родителя. Если встречено `\p`, где `PARENT_CHARACTER = 'p'`, то это интерпретируется, как ссылка на родителя. Если `0`, то выключено
- `USE_ARRAY_SYNTAX` - при `false` интерпретирует `property[2]` как полное имя свойства, а если `true`, то как `2` элемент массива `property`

Используйте `setBufferSize(int power)`, чтобы управлять размером буфера, который используется при парсинге. Позволяет подкорректировать размер, чтобы оставаться в кеше процессора и
значительно уменьшить кеш-промахи при парсинге.

## Добавление элементов

Учтите, что ключ резолвится в соответствии с настройками синтаксиса `JavaScript`.
Для всех методов существуют все перегруженные версии для:
- `byte`
- `short`
- `int`
- `long`
- `float`
- `double`
- `boolean`
- `String`
- `Json` - только для добавления. Для получения используйте `get(...)`, о котором будет дальше.
Также есть версии для массивов всех типов.
Для добавления используйте:
```
put(key, value); // кладёт value по пути key.
add(value); // кладёт value в текущий массив.
add(key, value); // кладёт value в массив по пути key
add(value[]); // создаёт новый Json массив и кладёт его
add(key, value[]); // создаёт новый Json массив и кладёт его по пути key
addAll(value[]); // не создаёт новый массив, а распаковывает элементы в этот
addAll(key, value[]); // распаковывает массов по пути key
```
`IJson` воспринимает `null` как полноценный `null` и на проверку существования `has(key)` будет выдавать `false`, т.к. иначе вы бы могли получить, что `has(key) = true; get(key).someMethod()`
и получить `NullPointerException`.

## Получение элементов
Для получения типа `Json` используйте методы из секции `Путешествие по json`
Для получения существуют множество методов и все их перегруженные версии:
```
getType(); // получить значение указанного типа
getType(key); // получить значение указанного типа по пути key
getTypeOr(key, value); // получить значение указанного типа по пути key. Если конечной точки не существует, то вернёт value. Если не существует промежуточной точки, то выбросит JsonNoSuchPropertyException
getTypeArray(); // массив указанного типа
getTypeArray(key); // массив указанного типа по пути key
getTypeArray(key, value); // то же самое, но если нет конечной точки, то вернёт value;

getTypeStream(); // возвращает Stream указанного типа.
getTypeStream(key); // возвращает Stream указанного типа по пути key.
getTypeStreamOr(key, value); // возвращает Stream указанного типа по пути key. Если нет конечного значения, то вернёт Arrays.stream(value)
```

## Путешествие по json

Для путешествия можно использовать следующие методы:
- `get(key)` - получить НОВЫЙ `Json` по пути `key`
- `go(key)` - передвинет текущий `Json` на `key`
- `back()` - подняться на 1 родителя наверх
- `back(int n)` - подняться на `n` родителей наверх. Если передан `0`, то поднимается на самый верх дерева




